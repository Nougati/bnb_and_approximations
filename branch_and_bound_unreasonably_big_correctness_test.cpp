/*****************************************************************************
 * branch_and_bound_night_test.cpp                                           *
 * Author: Nelson Frew                                                       *
 * First edit: 16/03/18                                                      *
 * Last edit: 20/03/18                                                       *
 *                                                                           *
 * Chapters:                                                                 *
 *   [25,7409] : WS RB Auto                                                  *
 *   [7411, 14795] : WS RB loweps                                            *
 *   [14797, 22181] : WS RB midloweps                                        * 
 *   [22183, 29567] : WS TB Auto                                             *
 *   [29569, 36953] : WS TB low eps                                          *
 *   [36955, 44339] : WS TB midlow eps                                       *
 *   [44341, 51725] : WS LE Auto                                             *
 *   [51727, 59111] : WS LE low eps                                          *
 *   [59113, 66497] : WS LE midloweps                                        *
 *                                                                           * 
 * Description:                                                              *
 *   Heavy unit tests to simply try the branch and bound on different        *
 *        instances.                                                         *
 * Some notes:                                                               * 
 *   I didn't include tests for instance types 11 to 16 due to limitations   * 
 *    with my reader. As it stands I probably won't need them but I should   * 
 *    resolve to incorporate them eventually.                                * 
 *   Also, there are no Vasrani DP tests for this as the algorithm has not   * 
 *    been worked on with the B&B algorithm.                                 * 
 *****************************************************************************/

#define TESTING
#include "branch_and_bound.c"
#include <gtest/gtest.h>
#include <time.h>
#include <math.h>

class branch_and_bound_correctnessTest : public testing::Test
{
  void SetUp(){
  }
  void TearDown(){
  }
};

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_auto_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_low_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, random_branching_willshmoy_midlow_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = RANDOM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_auto_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_low_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, truncation_branching_willshmoy_midlow_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = TRUNCATION_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_auto_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.0;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_low_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.1;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000.csv";
  /* For each 1_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_10000.csv";
  /* For each 1_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_1000000.csv";
  /* For each 1_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_50_100000.csv";
  /* For each 1_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000.csv";
  /* For each 1_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_10000.csv";
  /* For each 1_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_1000000.csv";
  /* For each 1_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_100_100000.csv";
  /* For each 1_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000.csv";
  /* For each 1_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_10000.csv";
  /* For each 1_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_1000000.csv";
  /* For each 1_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_200_100000.csv";
  /* For each 1_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000.csv";
  /* For each 1_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_10000.csv";
  /* For each 1_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_1000000.csv";
  /* For each 1_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_500_100000.csv";
  /* For each 1_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000.csv";
  /* For each 1_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_10000.csv";
  /* For each 1_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_1000000.csv";
  /* For each 1_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_1000_100000.csv";
  /* For each 1_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000.csv";
  /* For each 1_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_10000.csv";
  /* For each 1_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_1000000.csv";
  /* For each 1_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_2000_100000.csv";
  /* For each 1_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000.csv";
  /* For each 1_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_10000.csv";
  /* For each 1_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_1000000.csv";
  /* For each 1_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_5000_100000.csv";
  /* For each 1_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000.csv";
  /* For each 1_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_10000.csv";
  /* For each 1_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_1000000.csv";
  /* For each 1_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_1_10000_100000.csv";
  /* For each 1_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000.csv";
  /* For each 2_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_10000.csv";
  /* For each 2_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_1000000.csv";
  /* For each 2_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_50_100000.csv";
  /* For each 2_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000.csv";
  /* For each 2_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_10000.csv";
  /* For each 2_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_1000000.csv";
  /* For each 2_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_100_100000.csv";
  /* For each 2_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000.csv";
  /* For each 2_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_10000.csv";
  /* For each 2_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_1000000.csv";
  /* For each 2_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_200_100000.csv";
  /* For each 2_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000.csv";
  /* For each 2_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_10000.csv";
  /* For each 2_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_1000000.csv";
  /* For each 2_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_500_100000.csv";
  /* For each 2_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000.csv";
  /* For each 2_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_10000.csv";
  /* For each 2_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_1000000.csv";
  /* For each 2_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_1000_100000.csv";
  /* For each 2_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000.csv";
  /* For each 2_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_10000.csv";
  /* For each 2_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_1000000.csv";
  /* For each 2_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_2000_100000.csv";
  /* For each 2_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000.csv";
  /* For each 2_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_10000.csv";
  /* For each 2_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_1000000.csv";
  /* For each 2_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_5000_100000.csv";
  /* For each 2_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000.csv";
  /* For each 2_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_10000.csv";
  /* For each 2_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_1000000.csv";
  /* For each 2_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_2_10000_100000.csv";
  /* For each 2_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000.csv";
  /* For each 3_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_10000.csv";
  /* For each 3_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_1000000.csv";
  /* For each 3_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_50_100000.csv";
  /* For each 3_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000.csv";
  /* For each 3_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_10000.csv";
  /* For each 3_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_1000000.csv";
  /* For each 3_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_100_100000.csv";
  /* For each 3_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000.csv";
  /* For each 3_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_10000.csv";
  /* For each 3_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_1000000.csv";
  /* For each 3_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_200_100000.csv";
  /* For each 3_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000.csv";
  /* For each 3_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_10000.csv";
  /* For each 3_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_1000000.csv";
  /* For each 3_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_500_100000.csv";
  /* For each 3_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000.csv";
  /* For each 3_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_10000.csv";
  /* For each 3_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_1000000.csv";
  /* For each 3_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_1000_100000.csv";
  /* For each 3_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000.csv";
  /* For each 3_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_10000.csv";
  /* For each 3_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_1000000.csv";
  /* For each 3_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_2000_100000.csv";
  /* For each 3_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000.csv";
  /* For each 3_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_10000.csv";
  /* For each 3_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_1000000.csv";
  /* For each 3_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_5000_100000.csv";
  /* For each 3_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000.csv";
  /* For each 3_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_10000.csv";
  /* For each 3_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_1000000.csv";
  /* For each 3_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_3_10000_100000.csv";
  /* For each 3_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000.csv";
  /* For each 4_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_10000.csv";
  /* For each 4_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_1000000.csv";
  /* For each 4_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_50_100000.csv";
  /* For each 4_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000.csv";
  /* For each 4_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_10000.csv";
  /* For each 4_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_1000000.csv";
  /* For each 4_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_100_100000.csv";
  /* For each 4_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000.csv";
  /* For each 4_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_10000.csv";
  /* For each 4_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_1000000.csv";
  /* For each 4_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_200_100000.csv";
  /* For each 4_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000.csv";
  /* For each 4_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_10000.csv";
  /* For each 4_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_1000000.csv";
  /* For each 4_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_500_100000.csv";
  /* For each 4_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000.csv";
  /* For each 4_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_10000.csv";
  /* For each 4_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_1000000.csv";
  /* For each 4_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_1000_100000.csv";
  /* For each 4_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000.csv";
  /* For each 4_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_10000.csv";
  /* For each 4_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_1000000.csv";
  /* For each 4_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_2000_100000.csv";
  /* For each 4_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000.csv";
  /* For each 4_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_10000.csv";
  /* For each 4_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_1000000.csv";
  /* For each 4_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_5000_100000.csv";
  /* For each 4_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000.csv";
  /* For each 4_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_10000.csv";
  /* For each 4_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_1000000.csv";
  /* For each 4_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_inversestronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_4_10000_100000.csv";
  /* For each 4_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000.csv";
  /* For each 5_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_10000.csv";
  /* For each 5_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_1000000.csv";
  /* For each 5_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_50_100000.csv";
  /* For each 5_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000.csv";
  /* For each 5_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_10000.csv";
  /* For each 5_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_1000000.csv";
  /* For each 5_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_100_100000.csv";
  /* For each 5_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000.csv";
  /* For each 5_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_10000.csv";
  /* For each 5_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_1000000.csv";
  /* For each 5_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_200_100000.csv";
  /* For each 5_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000.csv";
  /* For each 5_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_10000.csv";
  /* For each 5_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_1000000.csv";
  /* For each 5_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_500_100000.csv";
  /* For each 5_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000.csv";
  /* For each 5_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_10000.csv";
  /* For each 5_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_1000000.csv";
  /* For each 5_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_1000_100000.csv";
  /* For each 5_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000.csv";
  /* For each 5_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_10000.csv";
  /* For each 5_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_1000000.csv";
  /* For each 5_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_2000_100000.csv";
  /* For each 5_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000.csv";
  /* For each 5_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_10000.csv";
  /* For each 5_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_1000000.csv";
  /* For each 5_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_5000_100000.csv";
  /* For each 5_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000.csv";
  /* For each 5_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_10000.csv";
  /* For each 5_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_1000000.csv";
  /* For each 5_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_almoststronglycorrelated_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_5_10000_100000.csv";
  /* For each 5_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000.csv";
  /* For each 6_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_50_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_10000.csv";
  /* For each 6_50_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_1000000.csv";
  /* For each 6_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_50_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_50_100000.csv";
  /* For each 6_50_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000.csv";
  /* For each 6_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_100_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_10000.csv";
  /* For each 6_100_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_1000000.csv";
  /* For each 6_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_100_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_100_100000.csv";
  /* For each 6_100_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000.csv";
  /* For each 6_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_200_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_10000.csv";
  /* For each 6_200_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_1000000.csv";
  /* For each 6_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_200_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_200_100000.csv";
  /* For each 6_200_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000.csv";
  /* For each 6_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_500_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_10000.csv";
  /* For each 6_500_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_1000000.csv";
  /* For each 6_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_500_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_500_100000.csv";
  /* For each 6_500_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000.csv";
  /* For each 6_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_1000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_10000.csv";
  /* For each 6_1000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_1000000.csv";
  /* For each 6_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_1000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_1000_100000.csv";
  /* For each 6_1000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000.csv";
  /* For each 6_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_2000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_10000.csv";
  /* For each 6_2000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_1000000.csv";
  /* For each 6_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_2000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_2000_100000.csv";
  /* For each 6_2000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000.csv";
  /* For each 6_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_5000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_10000.csv";
  /* For each 6_5000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_1000000.csv";
  /* For each 6_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_5000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_5000_100000.csv";
  /* For each 6_5000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000.csv";
  /* For each 6_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_10000_10000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_10000.csv";
  /* For each 6_10000_10000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_1000000.csv";
  /* For each 6_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_subsetsum_10000_10000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_6_10000_100000.csv";
  /* For each 6_10000_10000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

/*TODO PINK MARKER LOL */

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_50_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_100000.csv";
  /* For each 11_50_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_50_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_50_1000000.csv";
  /* For each 11_50_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_100_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_100000.csv";
  /* For each 11_100_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_100_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_100_1000000.csv";
  /* For each 11_100_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_200_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_100000.csv";
  /* For each 11_200_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_200_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_200_1000000.csv";
  /* For each 11_200_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_500_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_100000.csv";
  /* For each 11_500_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_500_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_500_1000000.csv";
  /* For each 11_500_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_1000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_100000.csv";
  /* For each 11_1000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_1000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_1000_1000000.csv";
  /* For each 11_1000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_2000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_100000.csv";
  /* For each 11_2000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_2000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_2000_1000000.csv";
  /* For each 11_2000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_5000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_100000.csv";
  /* For each 11_5000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_5000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_5000_1000000.csv";
  /* For each 11_5000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000.csv";
  /* For each 11_10000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}
TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_10000_100000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_100000.csv";
  /* For each 11_10000_100000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_similarweights_10000_1000000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_9_10000_1000000.csv";
  /* For each 11_10000_1000000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_uncorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_11_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_weaklycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_12_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_stronglycorrelatedspan_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_13_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_mstr_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_14_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_pceil_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_15_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_20_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_20_1000.csv";
  /* For each 11_20_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_50_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_50_1000.csv";
  /* For each 11_50_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_100_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_100_1000.csv";
  /* For each 11_100_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_200_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_200_1000.csv";
  /* For each 11_200_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_500_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_500_1000.csv";
  /* For each 11_500_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_1000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_1000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_2000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_2000_1000.csv";
  /* For each 11_2000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_5000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_5000_1000.csv";
  /* For each 11_5000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

TEST(branch_and_bound_correctnessTest, linear_enum_branching_willshmoy_midlow_eps_circle_10000_1000)
{
  /* Need to test each branching strategy against all instances */
  /* This tests 4000 different problems for each strategy */
  double epsilon = 0.3;
  FILE *logging_stream = stdout;
  int logging_rule = NO_LOGGING;
  int DP_method = WILLIAMSON_SHMOY;
  int n, capacity, z;
  int *profits, *weights, *x;
  int z_out = 0;
  int number_of_nodes = 1;
  /* Random branching */
  int branching_strategy = LINEAR_ENUM_BRANCHING;
  time_t seed = time(NULL);
  const char *problem_file = "knapPI_16_10000_1000.csv";
  /* For each 11_1000_1000 */
  for(int i = 1; i <= 1; i++)
  {
    pisinger_reader(&n, &capacity, &z, &profits, &weights, &x, (char*) problem_file, i);
    int sol_out[n];
    branch_and_bound_bin_knapsack(profits, weights, x, capacity, z, &z_out, 
                                sol_out, n, (char*) problem_file, branching_strategy, seed,
																	DP_method, logging_rule, logging_stream, epsilon, &number_of_nodes);
    ASSERT_EQ(z_out, z);
  }
}

int main(int argc, char **argv)
{
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
